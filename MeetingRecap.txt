Quick recap Philip, Andrew, and George discussed the development of a test environment using Terraform, with a focus on creating a workspace with a full stack of baseline applications. They also discussed the design and configuration of an application, including the need for front-end and back-end APIs, and the potential for fault injection and chaos engineering. Issues with Github repository access and authentication were also addressed, along with the progress of their project and the need for a summary of the work done. Next steps • Andrew to create a folder in the Chs Dev Terraform environment for the test application. • Andrew to use the app template folder from the Invt Prod or SHS Prod environment as a reference for the test application's module design. • Andrew to deploy the test application using the defined modules and infrastructure in the new folder. • Andrew to test the application's functionality and failure scenarios, such as database writes, backend calls, and load balancer configurations. • Philip to provide access to the Cloud Test repository for Andrew. • Philip to create a ticket for Andrew's access request to the UCOP Scalar environment. • Andrew to generate a new SSH key for the UCOP Scalar environment and update the credentials in the Terraform configuration. • Andrew to commit the test application code to the main branch of the Cloud Test repository. • Andrew to run the Terraform plan and apply commands to deploy the test application. • Andrew to pair program with Philip or George for any questions or issues during the deployment and testing process. Summary Test Environment for Application Developers Philip discussed the need for a test environment that can be deployed and destroyed without affecting the application developers' work. He proposed using Terraform to create a workspace with a full stack of baseline applications, including a load balancer, a front end, a back end, a database, and a custom map. The goal is to demonstrate the functionality of the applications in different scenarios, such as when the front end or back end is down, or when the entire zone is unavailable. Andrew suggested using a simple "Hello, world" app to test the functionality. Philip also mentioned the possibility of using the environment to test disaster recovery processes and high availability. The team agreed to start with a simple app and gradually add more features. UI Development and Project Objectives Philip and Andrew discussed the development of a UI for their project. They agreed on using TypeScript and a basic UI framework like Tailwind, but decided against using complex frameworks like React or Angular. The UI should be able to demonstrate communication to the backends and help identify any missing components. Philip also mentioned the potential for demonstrating infrastructure functionalities like caching and message queues in the future. Andrew suggested writing down the top objectives of the project to clarify the goals. Front-End API and Back-End Discussion Philip discussed the need for a front-end API to handle incoming calls and a back-end API to interact with the database. He suggested a single front-end application with a public URL, displaying database data and timestamps. The back-end should be able to read and write to the database. Philip also considered the need for fault injection and chaos engineering to simulate failures. Andrew suggested having a health status API for the back-end and the front-end to call into. The team debated whether to use a load balancer in front of the back-end or to call it directly. Designing and Configuring the Application Philip and Andrew discussed the design and configuration of an application. They considered using environment variables for storing and updating configuration, and the possibility of pulling data from a parameter store. They also discussed the need for endpoints, ports, and health status for dependencies. Andrew suggested using a data generator to avoid using Selenium. Philip expressed a desire for a clear and simple app, and they agreed to start with a Python-based solution. They also discussed the potential for the front end to generate its own data. The conversation ended with the question of how to deploy the app on top of the infrastructure. Automating Deployment With Terraform and Ansible Philip, Andrew, and George discussed the current process of deploying code from source to deployment, which involves manually copying and pasting war files and restarting applications. They also mentioned the use of Puppet and Ansible for building out EC2 nodes and deploying applications. The team considered using Terraform to automate the deployment process, with the idea of using user data scripts to deploy code on boot. However, they noted that they don't have any agents in the environment, which would require a gateway for Scalar to access the hosts. The team agreed to start with a simple approach and enhance it over time. New Application Deployment Strategy Discussion Philip and Andrew discussed the deployment of a new application. They decided to use a monolithic repository for the application code, which would be public and part of the UCOP organization. The Terraform workspace for the deployment would be in the UCOP Terraform deployments repository. They also discussed the need for a separate repository for the front-end and back-end code. Andrew suggested using a client and server approach for the deployment. Philip agreed to this approach. They also discussed the need for a separate folder for the new application in the CHS Dev environment. Project Development and Implementation Discussion Philip and Andrew discussed the development of a new project, with a focus on its implementation and potential challenges. They agreed on a two-week timeframe for the project, with Andrew suggesting a load balancer to simplify the data flow between the front and back end. They also discussed the use of environment variables and the potential for storing data in a database. Andrew confirmed his access to Terraform and the possibility of deploying locally. They ended the conversation with a plan to test the project in the Chs Dev environment. Github Repository Access Issues Philip and Andrew discussed issues with their Github repository access and authentication. Philip suggested that the modules they were trying to download might be private, and Andrew confirmed that he had updated his public key, which might be causing the permission problems. They also discussed the lack of a proper Github organization for their work, which led to some frustration. Project Access and Terraform Deployment Philip and Andrew discussed the progress of their project, which involved testing access for Andrew to get started. They aimed to end up with a Terraform workspace that could be deployed with a single click. However, they encountered issues with Safari and 2-factor authentication. Philip suggested creating a ticket for access to the Scalar console. Andrew confirmed his email address for the project. AWS Access and Scalar Troubleshooting Philip and Andrew discussed issues with logging into AWS and accessing a repository in the UKOP ACME. Khalid guided them through the process of generating a personal token and accessing the environment. Andrew encountered an error related to an organization not found in Scalar. The team decided to save the current page and continue troubleshooting. System Issues and Project Management Andrew and Philip discussed issues with their system, including errors and slow performance. They also discussed the use of Terraform and Github for their project. Philip suggested Andrew to use Github Desktop and to clone a repository for the application. They also discussed the need to invite Ron Mintz and the possibility of renaming the repository. Towards the end, they discussed the need to close a task and the use of the task management system. Planning Application Development and Pair Programming Philip discussed the need for a summary of the work done and time spent, which he felt would be appreciated. He also mentioned the possibility of using the current project as an example to improve their modules for automation. Andrew agreed with Philip's suggestions. Philip then explained the goals of the application they are working on, which includes testing the state of systems and data recovery. He also mentioned the intention to use their standard modules for deployment and monitoring. Andrew expressed his familiarity with Terraform and agreed to create a folder for the project. They also discussed the possibility of pair programming for the project.
